

create or replace table tmp_out
as
select p_brand, p_mfgr, P_CONTAINER, p_brand||p_mfgr||P_CONTAINER as conct,  p_size
from SNOWFLAKE_SAMPLE_DATA.TPCH_SF1000.PART
;

select count(*) from tmp_out;



CREATE OR REPLACE WAREHOUSE SNOWPARK_OPT_WH
  WAREHOUSE_TYPE = 'SNOWPARK-OPTIMIZED' -- This is the key parameter for memory
  WAREHOUSE_SIZE = 'MEDIUM'
  AUTO_SUSPEND = 60
  AUTO_RESUME = TRUE
  INITIALLY_SUSPENDED = TRUE
  COMMENT = 'Warehouse for Snowpark, Python UDFs, and Stored Procedures';


-----------------------
    ---------


    --example

    CREATE OR REPLACE TABLE SALES_DATA AS
SELECT 'North' AS REGION, 'Electronics' AS PRODUCT_CATEGORY, 1200 AS SALE_AMOUNT
UNION ALL
SELECT 'North', 'Electronics', 1250
UNION ALL
SELECT 'North', 'Electronics', 1100
UNION ALL
SELECT 'North', 'Electronics', 50000
UNION ALL
SELECT 'South', 'Books', 80
UNION ALL
SELECT 'South', 'Books', 85
UNION ALL
SELECT 'South', 'Books', 90
UNION ALL
SELECT 'South', 'Books', 750
UNION ALL
SELECT 'North', 'Books', 60
UNION ALL
SELECT 'North', 'Books', 65;




-- Final Version: Uses the correct stateful handler pattern.
CREATE OR REPLACE FUNCTION DETECT_OUTLIERS_FINAL_V2 (
    "REGION" VARCHAR,
    "PRODUCT_CATEGORY" VARCHAR,
    "SALE_AMOUNT" INT
)
RETURNS TABLE (
    "REGION" VARCHAR,
    "PRODUCT_CATEGORY" VARCHAR,
    "SALE_AMOUNT" INT,
    "OUTLIER_SCORE" FLOAT,
    "IS_OUTLIER" BOOLEAN
)
LANGUAGE PYTHON
RUNTIME_VERSION = '3.12'
PACKAGES = ('pandas', 'pyod', 'scikit-learn')
HANDLER = 'OutlierDetector'
AS
$$
import pandas as pd
from pyod.models.iforest import IForest
from typing import Iterable, Tuple

# This class structure is the correct and robust way to handle partition-wise UDTFs.
class OutlierDetector:
    
    # 1. __init__ is called ONCE per partition. We initialize a list to hold the rows.
    def __init__(self):
        self._rows = []

    # 2. process() is called FOR EACH ROW in the partition. 
    #    It receives scalar values and simply stores them.
    #    Crucially, it must return an iterable, even if it's empty.
    def process(self, region: str, category: str, amount: int) -> Iterable[Tuple]:
        self._rows.append((region, category, amount))
        # This method MUST return an iterable. An empty list is the correct choice
        # when we want to delay processing until the end.
        return []

    # 3. end_partition() is called ONCE after all rows for the partition have been processed.
    #    This is where the actual logic is executed.
    def end_partition(self) -> Iterable[Tuple]:
        
        # Convert the collected rows into a DataFrame. This is now safe.
        df = pd.DataFrame(self._rows, columns=['REGION', 'PRODUCT_CATEGORY', 'SALE_AMOUNT'])
        
        data_to_assess = df[['SALE_AMOUNT']].dropna()
        
        if data_to_assess.empty or len(data_to_assess) < 4:
            df['OUTLIER_SCORE'] = None
            df['IS_OUTLIER'] = False
        else:
            model = IForest(contamination=0.25, random_state=42)
            model.fit(data_to_assess.values)

            results = pd.DataFrame({
                'OUTLIER_SCORE': model.decision_scores_,
                'IS_OUTLIER': model.labels_.astype(bool)
            }, index=data_to_assess.index)

            df = df.merge(results, left_index=True, right_index=True, how='left')
            df['IS_OUTLIER'].fillna(False, inplace=True)

        # Yield the results row by row. The tuple order must match the RETURNS TABLE clause.
        for _, row in df.iterrows():
            yield (
                row['REGION'], 
                row['PRODUCT_CATEGORY'], 
                row['SALE_AMOUNT'], 
                row['OUTLIER_SCORE'], 
                row['IS_OUTLIER']
            )
$$;



CREATE OR REPLACE TABLE SALES_DATA_OUTLIERS_RESULT AS
SELECT 
    t.REGION,
    t.PRODUCT_CATEGORY,
    t.SALE_AMOUNT,
    t.OUTLIER_SCORE,
    t.IS_OUTLIER
FROM 
    SALES_DATA s,
    TABLE(DETECT_OUTLIERS_FINAL_V2(REGION, PRODUCT_CATEGORY, SALE_AMOUNT) 
          OVER (PARTITION BY REGION, PRODUCT_CATEGORY)) t;

-- Verify the final result
SELECT * FROM SALES_DATA_OUTLIERS_RESULT ORDER BY REGION, PRODUCT_CATEGORY, IS_OUTLIER, SALE_AMOUNT;



    




-- Final Version: Uses the correct stateful handler pattern.
CREATE OR REPLACE FUNCTION DETECT_OUTLIERS_FINAL_V2 (
    "P_BRAND" VARCHAR,
    "P_MFGR" VARCHAR,
    "P_CONTAINER" VARCHAR,
    "P_SIZE" INT
)
RETURNS TABLE (
    "P_BRAND" VARCHAR,
    "P_MFGR" VARCHAR,
    "P_CONTAINER" VARCHAR,
    "P_SIZE" INT,
    "OUTLIER_SCORE" FLOAT,
    "IS_OUTLIER" BOOLEAN
)
LANGUAGE PYTHON
RUNTIME_VERSION = '3.12'
PACKAGES = ('pandas', 'pyod', 'scikit-learn')
HANDLER = 'OutlierDetector'
AS
$$
import pandas as pd
from pyod.models.iforest import IForest
from typing import Iterable, Tuple

# This class structure is the correct and robust way to handle partition-wise UDTFs.
class OutlierDetector:
    
    # 1. __init__ is called ONCE per partition. We initialize a list to hold the rows.
    def __init__(self):
        self._rows = []

    # 2. process() is called FOR EACH ROW in the partition. 
    #    It receives scalar values and simply stores them.
    #    Crucially, it must return an iterable, even if it's empty.
    def process(self, brand: str, mfgr: str, container: str, size: int) -> Iterable[Tuple]:
        self._rows.append((brand, mfgr, container, size))
        # This method MUST return an iterable. An empty list is the correct choice
        # when we want to delay processing until the end.
        return []

    # 3. end_partition() is called ONCE after all rows for the partition have been processed.
    #    This is where the actual logic is executed.
    def end_partition(self) -> Iterable[Tuple]:
        
        # Convert the collected rows into a DataFrame. This is now safe.
        df = pd.DataFrame(self._rows, columns=['P_BRAND', 'P_MFGR', 'P_CONTAINER', 'P_SIZE'])

    
        data_to_assess = df[['P_SIZE']].dropna()
        
        if data_to_assess.empty or len(data_to_assess) < 4:
            df['OUTLIER_SCORE'] = None
            df['IS_OUTLIER'] = False
        else:
            model = IForest(contamination=0.25, random_state=42)
            model.fit(data_to_assess.values)

            results = pd.DataFrame({
                'OUTLIER_SCORE': model.decision_scores_,
                'IS_OUTLIER': model.labels_.astype(bool)
            }, index=data_to_assess.index)

            df = df.merge(results, left_index=True, right_index=True, how='left')
            df['IS_OUTLIER'].fillna(False, inplace=True)

        # Yield the results row by row. The tuple order must match the RETURNS TABLE clause.
        for _, row in df.iterrows():
            yield (
                row['P_BRAND'], 
                row['P_MFGR'], 
                row['P_CONTAINER'], 
                row['P_SIZE'], 
                row['OUTLIER_SCORE'], 
                row['IS_OUTLIER']
            )
$$;



CREATE OR REPLACE TABLE SALES_DATA_OUTLIERS_UDTF2 AS
SELECT T.*
FROM tmp_out S,
     TABLE(DETECT_OUTLIERS_FINAL_V2(P_BRAND,P_MFGR, P_CONTAINER, P_SIZE) 
           OVER (PARTITION BY P_BRAND,P_MFGR, P_CONTAINER)) T;

select count(*) from tmp_out;
           

